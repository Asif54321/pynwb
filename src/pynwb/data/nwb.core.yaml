datasets:

- neurodata_type_def: NWBData
  doc: An abstract data type for a dataset

- neurodata_type_def: VectorData
  neurodata_type_inc: NWBData
  doc: A dataset indexed by pointer (see VectorIndex)
  attributes:
  - name: description
    dtype: text
    doc: A description of what these vectors represent

- neurodata_type_def: VectorIndex
  neurodata_type_inc: NWBData
  doc: An array of pointers that index the first dimension of a target VectorData
  attributes:
  - name: target
    dtype:
      target_type: VectorData
      reftype: object
    doc: A reference to the target dataset that this index applies to

- neurodata_type_def: ElementIdentifiers
  neurodata_type_inc: NWBData
  dtype: int
  doc: A unique identifier for values within a dataset, e.g. rows of a DynamicTable
  default_name: element_id
  shape:
  - null

- neurodata_type_def: DynamicTableRegion
  neurodata_type_inc: VectorData
  dtype: int
  doc: a region/index into a DynamicTable
  attributes:
  - name: table
    dtype:
      target_type: DynamicTable
      reftype: object
    doc: A reference to the DynamicTable that this region applies to
  - name: description
    dtype: text
    doc: A description of what this table region points to


groups:

- neurodata_type_def: NWBContainer
  doc: An abstract data type for a generic container storing collections of data
    and metadata. Base type for all data and metadata containers.

- neurodata_type_def: NWBDataInterface
  neurodata_type_inc: NWBContainer
  doc: An abstract data type for a generic container storing collections of data,
    as opposed to metadata.

- neurodata_type_def: DynamicTable
  neurodata_type_inc: NWBDataInterface
  doc: A group containing multiple datasets that are aligned on the first dimension
    (Currently, this requirement if left up to APIs to check and enforce). Apart from
    a column that contains unique identifiers for each row there are no other required
    datasets. Users are free to add any number of VectorData objects here. Table
    functionality is already supported through compound types, which is analogous
    to storing an array-of-structs. DynamicTable can be thought of as a struct-of-arrays.
    This provides an alternative structure to choose from when optimizing storage
    for anticipated access patterns. Additionally, this type provides a way of creating
    a table without having to define a compound type up front. Although this convenience
    may be attractive, users should think carefully about how data will be accessed.
    DynamicTable is more appropriate for column-centric access, whereas a dataset
    with a compound type would be more appropriate for row-centric access. Finally,
    data size should also be taken into account. For small tables, performance loss
    may be an acceptable trade-off for the flexibility of a DynamicTable. For example,
    DynamicTable was originally developed for storing trial data and spike unit metadata.
    Both of these use cases are expected to produce relatively small tables, so the
    spatial locality of multiple datasets present in a DynamicTable is not expected
    to have a significant performance impact. Additionally, requirements of trial
    and unit metadata tables are sufficiently diverse that performance implications
    can be overlooked in favor of usability.
  attributes:
  - name: colnames
    dtype: ascii
    doc: The names of the columns of this table. This should be used to specify
      an order to the columns
    shape:
    - null
  - name: description
    dtype: text
    doc: A description of what is in this dynamic table
  datasets:
  - neurodata_type_inc: ElementIdentifiers
    name: id
    dtype: int
    doc: The unique identifiers for the rows of this dynamic table
    shape:
    - null
  - neurodata_type_inc: VectorData
    doc: The vector columns of this dynamic table
    quantity: '*'
  - neurodata_type_inc: VectorIndex
    doc: The indices for the vector columns of this dynamic table
    quantity: '*'
